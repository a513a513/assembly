## ğŸ“˜ 3.9.1 ë‹¨ë‹µí˜• (ë¬¸ì œ & ì •ë‹µ)

# ğŸ“˜ Assembly Language ë‹¨ë‹µí˜• ë¬¸ì œ (1~29) ì •ë¦¬

---

### **1. Provide examples of three different instruction mnemonics.**

**í•œê¸€:** ì„¸ ê°€ì§€ ë‹¤ë¥¸ ëª…ë ¹ì–´ ë‹ˆëª¨ë‹‰ì˜ ì˜ˆë¥¼ ì œì‹œí•˜ì‹œì˜¤.

âœ… ì •ë‹µ: `MOV`, `ADD`, `SUB`

---

### **2. What is a calling convention, and how is it used in assembly language declarations?**

**í•œê¸€:** í˜¸ì¶œ ê·œì•½ì´ë€ ë¬´ì—‡ì´ë©°, ì–´ì…ˆë¸”ë¦¬ ì–¸ì–´ ì„ ì–¸ì—ì„œ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ê°€?

âœ… ì •ë‹µ: í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ì¸ì ì „ë‹¬, ë°˜í™˜ê°’, ìŠ¤íƒ ì •ë¦¬ ê·œì¹™ì„ ì •í•œ ê²ƒ. ì–´ì…ˆë¸”ë¦¬ì—ì„œëŠ” `PROTO` ë“±ì„ í†µí•´ í˜¸ì¶œ ê·œì•½ì„ ì •ì˜.

---

### **3. How do you reserve space for the stack in a program?**

**í•œê¸€:** í”„ë¡œê·¸ë¨ì—ì„œ ìŠ¤íƒì„ ìœ„í•œ ê³µê°„ì„ ì–´ë–»ê²Œ ì˜ˆì•½í•˜ëŠ”ê°€?

âœ… ì •ë‹µ: `.STACK 100h` ì™€ ê°™ì´ ìŠ¤íƒ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„ ì–¸.

---

### **4. Explain why the term assembler language is not quite correct.**

**í•œê¸€:** â€œassembler languageâ€ë¼ëŠ” ìš©ì–´ê°€ ì •í™•í•˜ì§€ ì•Šì€ ì´ìœ ë¥¼ ì„¤ëª…í•˜ì‹œì˜¤.

âœ… ì •ë‹µ: AssemblerëŠ” í”„ë¡œê·¸ë¨ ì´ë¦„ì´ê³ , ì–¸ì–´ì˜ ì˜¬ë°”ë¥¸ ì´ë¦„ì€ **assembly language**.

---

### **5. Explain the difference between big endian and little endian. Also, look up the origins of this term on the Web.**

**í•œê¸€:** ë¹… ì—”ë””ì–¸ê³¼ ë¦¬í‹€ ì—”ë””ì–¸ì˜ ì°¨ì´ë¥¼ ì„¤ëª…í•˜ê³ , ì´ ìš©ì–´ì˜ ê¸°ì›ì„ ì°¾ì•„ë³´ì‹œì˜¤.

âœ… ì •ë‹µ:

- Big endian: ê°€ì¥ ì¤‘ìš”í•œ ë°”ì´íŠ¸(MSB)ë¥¼ ë‚®ì€ ì£¼ì†Œì— ì €ì¥.
- Little endian: ê°€ì¥ ëœ ì¤‘ìš”í•œ ë°”ì´íŠ¸(LSB)ë¥¼ ë‚®ì€ ì£¼ì†Œì— ì €ì¥.
- ê¸°ì›: *ê±¸ë¦¬ë²„ ì—¬í–‰ê¸°*ì—ì„œ ë‹¬ê±€ì„ ê¹¨ëŠ” ë°©ì‹(Big end vs Little end).

---

### **6. Why might you use a symbolic constant rather than an integer literal in your code?**

**í•œê¸€:** ì •ìˆ˜ ë¦¬í„°ëŸ´ ëŒ€ì‹  ê¸°í˜¸ ìƒìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ”?

âœ… ì •ë‹µ: ê°€ë…ì„± ì¦ê°€, ìœ ì§€ë³´ìˆ˜ ìš©ì´, í•œ ê³³ë§Œ ìˆ˜ì •í•´ë„ ì „ì²´ ë°˜ì˜.

---

### **7. How is a source file different from a listing file?**

**í•œê¸€:** ì†ŒìŠ¤ íŒŒì¼ê³¼ ë¦¬ìŠ¤íŒ… íŒŒì¼ì˜ ì°¨ì´ëŠ”?

âœ… ì •ë‹µ: ì†ŒìŠ¤ íŒŒì¼(.asm)ì€ ì‚¬ëŒì´ ì‘ì„±, ë¦¬ìŠ¤íŒ… íŒŒì¼(.lst)ì€ ì–´ì…ˆë¸”ëŸ¬ê°€ ìƒì„±(ì£¼ì†Œ, ê¸°ê³„ì–´, ì˜¤ë¥˜ í¬í•¨).

---

### **8. How are data labels and code labels different?**

**í•œê¸€:** ë°ì´í„° ë ˆì´ë¸”ê³¼ ì½”ë“œ ë ˆì´ë¸”ì˜ ì°¨ì´ëŠ”?

âœ… ì •ë‹µ: ë°ì´í„° ë ˆì´ë¸” â†’ ë³€ìˆ˜/ë°ì´í„° ì´ë¦„, ì½”ë“œ ë ˆì´ë¸” â†’ ë¶„ê¸°/ì í”„ ìœ„ì¹˜ ì´ë¦„.

---

### **9. (True/False): An identifier cannot begin with a numeric digit.**

**í•œê¸€:** ì‹ë³„ìëŠ” ìˆ«ìë¡œ ì‹œì‘í•  ìˆ˜ ì—†ë‹¤.

âœ… ì •ë‹µ: True

---

### **10. (True/False): A hexadecimal literal may be written as 0x3A.**

**í•œê¸€:** 16ì§„ìˆ˜ ë¦¬í„°ëŸ´ì€ 0x3Aì™€ ê°™ì´ ì“¸ ìˆ˜ ìˆë‹¤.

âœ… ì •ë‹µ: True (MASMì—ì„œëŠ” `3Ah`ë„ ê°€ëŠ¥)

---

### **11. (True/False): Assembly language directives execute at runtime.**

**í•œê¸€:** ì–´ì…ˆë¸”ë¦¬ ì§€ì‹œë¬¸ì€ ì‹¤í–‰ ì‹œê°„ì— ì‹¤í–‰ëœë‹¤.

âœ… ì •ë‹µ: False (ì–´ì…ˆë¸” ì‹œì ì—ë§Œ ì‘ë™)

---

### **12. (True/False): Assembly language directives can be written in any combination of uppercase and lowercase letters.**

**í•œê¸€:** ì§€ì‹œë¬¸ì€ ëŒ€ì†Œë¬¸ìë¥¼ í˜¼í•©í•´ ì“¸ ìˆ˜ ìˆë‹¤.

âœ… ì •ë‹µ: True

---

### **13. Name the four basic parts of an assembly language instruction.**

**í•œê¸€:** ì–´ì…ˆë¸”ë¦¬ ëª…ë ¹ì–´ì˜ ë„¤ ê°€ì§€ ê¸°ë³¸ ë¶€ë¶„ì€?

âœ… ì •ë‹µ: Label, Mnemonic, Operand(s), Comment

---

### **14. (True/False): MOV is an example of an instruction mnemonic.**

**í•œê¸€:** MOVëŠ” ëª…ë ¹ì–´ ë‹ˆëª¨ë‹‰ì˜ ì˜ˆì´ë‹¤.

âœ… ì •ë‹µ: True

---

### **15. (True/False): A code label is followed by a colon (:), but a data label does not end with a colon.**

**í•œê¸€:** ì½”ë“œ ë ˆì´ë¸”ì€ ì½œë¡ (:)ìœ¼ë¡œ ëë‚˜ì§€ë§Œ, ë°ì´í„° ë ˆì´ë¸”ì€ ì½œë¡ ìœ¼ë¡œ ëë‚˜ì§€ ì•ŠëŠ”ë‹¤.

âœ… ì •ë‹µ: True

---

### **16. Show an example of a block comment.**

**í•œê¸€:** ë¸”ë¡ ì£¼ì„ì˜ ì˜ˆë¥¼ ì œì‹œí•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
COMMENT !
ì´ê²ƒì€ ë¸”ë¡ ì£¼ì„ì…ë‹ˆë‹¤.
ì—¬ëŸ¬ ì¤„ ì‘ì„± ê°€ëŠ¥.
!

```

---

### **17. Why is it not a good idea to use numeric addresses when writing instructions that access variables?**

**í•œê¸€:** ë³€ìˆ˜ë¥¼ ì ‘ê·¼í•  ë•Œ ìˆ«ì ì£¼ì†Œë¥¼ ì“°ë©´ ì•ˆ ì¢‹ì€ ì´ìœ ëŠ”?

âœ… ì •ë‹µ: ê°€ë…ì„± ì €í•˜, ìœ ì§€ë³´ìˆ˜ ì–´ë ¤ì›€, ë©”ëª¨ë¦¬ ì£¼ì†Œ ë³€ê²½ ì‹œ ì½”ë“œ ì „ì²´ ìˆ˜ì • í•„ìš”.

---

### **18. What type of argument must be passed to the ExitProcess procedure?**

**í•œê¸€:** ExitProcessì— ì–´ë–¤ ì¸ìë¥¼ ì „ë‹¬í•´ì•¼ í•˜ëŠ”ê°€?

âœ… ì •ë‹µ: 32ë¹„íŠ¸ ì •ìˆ˜(DWORD, ì¢…ë£Œ ì½”ë“œ).

---

### **19. Which directive ends a procedure?**

**í•œê¸€:** ì–´ë–¤ ì§€ì‹œì–´ê°€ í”„ë¡œì‹œì €ë¥¼ ëë‚´ëŠ”ê°€?

âœ… ì •ë‹µ: `ENDP`

---

### **20. In 32-bit mode, what is the purpose of the identifier in the END directive?**

**í•œê¸€:** 32ë¹„íŠ¸ ëª¨ë“œì—ì„œ END ì§€ì‹œë¬¸ì˜ ì‹ë³„ìëŠ” ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ê°€?

âœ… ì •ë‹µ: í”„ë¡œê·¸ë¨ì˜ ì‹œì‘ ì§€ì (entry point)ì„ ì§€ì •.

---

### **21. What is the purpose of the PROTO directive?**

**í•œê¸€:** PROTO ì§€ì‹œë¬¸ì˜ ëª©ì ì€?

âœ… ì •ë‹µ: ì™¸ë¶€ ë˜ëŠ” ë¯¸ë¦¬ ì •ì˜ë˜ì§€ ì•Šì€ í”„ë¡œì‹œì €ë¥¼ ì„ ì–¸í•˜ì—¬ í˜¸ì¶œ ê·œì•½ì„ ì•Œë ¤ì¤Œ.

---

### **22. (True/False): An Object file is produced by the Linker.**

**í•œê¸€:** ì˜¤ë¸Œì íŠ¸ íŒŒì¼ì€ ë§ì»¤ê°€ ë§Œë“ ë‹¤.

âœ… ì •ë‹µ: False (ì–´ì…ˆë¸”ëŸ¬ê°€ ìƒì„±)

---

### **23. (True/False): A Listing file is produced by the Assembler.**

**í•œê¸€:** ë¦¬ìŠ¤íŒ… íŒŒì¼ì€ ì–´ì…ˆë¸”ëŸ¬ê°€ ë§Œë“ ë‹¤.

âœ… ì •ë‹µ: True

---

### **24. (True/False): A link library is added to a program just before producing an Executable file.**

**í•œê¸€:** ì‹¤í–‰ íŒŒì¼ ìƒì„± ì§ì „ì— ë§í¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì¶”ê°€ëœë‹¤.

âœ… ì •ë‹µ: True

---

### **25. Which data directive creates a 32-bit signed integer variable?**

**í•œê¸€:** 32ë¹„íŠ¸ ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜ ë³€ìˆ˜ë¥¼ ë§Œë“œëŠ” ì§€ì‹œì–´ëŠ”?

âœ… ì •ë‹µ: `SDWORD`

---

### **26. Which data directive creates a 16-bit signed integer variable?**

**í•œê¸€:** 16ë¹„íŠ¸ ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜ ë³€ìˆ˜ë¥¼ ë§Œë“œëŠ” ì§€ì‹œì–´ëŠ”?

âœ… ì •ë‹µ: `SWORD`

---

### **27. Which data directive creates a 64-bit unsigned integer variable?**

**í•œê¸€:** 64ë¹„íŠ¸ ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜ ë³€ìˆ˜ë¥¼ ë§Œë“œëŠ” ì§€ì‹œì–´ëŠ”?

âœ… ì •ë‹µ: `QWORD`

---

### **28. Which data directive creates an 8-bit signed integer variable?**

**í•œê¸€:** 8ë¹„íŠ¸ ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜ ë³€ìˆ˜ë¥¼ ë§Œë“œëŠ” ì§€ì‹œì–´ëŠ”?

âœ… ì •ë‹µ: `SBYTE`

---

### **29. Which data directive creates a 10-byte packed BCD variable?**

**í•œê¸€:** 10ë°”ì´íŠ¸ íŒ¨í‚¹ëœ BCD ë³€ìˆ˜ë¥¼ ë§Œë“œëŠ” ì§€ì‹œì–´ëŠ”?

âœ… ì •ë‹µ: `TBYTE`

# ğŸ“˜ 3.9.2 Algorithm Workbench

---

### **1. Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.**

**í•œê¸€:** ì •ìˆ˜ 25ë¥¼ 10ì§„ìˆ˜, 2ì§„ìˆ˜, 8ì§„ìˆ˜, 16ì§„ìˆ˜ í˜•ì‹ìœ¼ë¡œ ë‚˜íƒ€ë‚´ëŠ” ë„¤ ê°€ì§€ ê¸°í˜¸ ìƒìˆ˜ë¥¼ ì •ì˜í•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
DEC25 = 25
BIN25 = 11001b
OCT25 = 31o
HEX25 = 19h

```

---

### **2. Find out, by trial and error, if a program can have multiple code and data segments.**

**í•œê¸€:** ì‹œí–‰ì°©ì˜¤ë¥¼ í†µí•´ í”„ë¡œê·¸ë¨ì´ ì—¬ëŸ¬ ê°œì˜ ì½”ë“œ ì„¸ê·¸ë¨¼íŠ¸ì™€ ë°ì´í„° ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ì‹œì˜¤.

âœ… ì •ë‹µ: ëŒ€ë¶€ë¶„ì˜ ì–´ì…ˆë¸”ëŸ¬ì—ì„œ **ì—¬ëŸ¬ ë°ì´í„°/ì½”ë“œ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆìœ¼ë‚˜, ì‹¤ì œë¡œëŠ” ë§ì»¤ì—ì„œ í•˜ë‚˜ì˜ ì‹¤í–‰ ê°€ëŠ¥í•œ ì„¸ê·¸ë¨¼íŠ¸ë¡œ ë³‘í•©ë¨**.

---

### **3. Create a data definition for a doubleword that stored it in memory in big endian format.**

**í•œê¸€:** ë©”ëª¨ë¦¬ì— ë¹… ì—”ë””ì–¸ í˜•ì‹ìœ¼ë¡œ ì €ì¥ë˜ëŠ” ë”ë¸”ì›Œë“œ ë°ì´í„° ì •ì˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
myVal BYTE 12h, 34h, 56h, 78h   ; ë¹… ì—”ë””ì–¸ (12345678h)

```

---

### **4. Find out if you can declare a variable of type DWORD and assign it a negative value. What does this tell you about the assemblerâ€™s type checking?**

**í•œê¸€:** DWORD ë³€ìˆ˜ì— ìŒìˆ˜ë¥¼ í• ë‹¹í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ì‹œì˜¤. ì´ê²ƒì´ ì–´ì…ˆë¸”ëŸ¬ì˜ íƒ€ì… ê²€ì‚¬ì— ëŒ€í•´ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ê°€?

âœ… ì •ë‹µ:

ê°€ëŠ¥í•˜ë‹¤. (ì˜ˆ: `myVar DWORD -5`)

ğŸ‘‰ ì–´ì…ˆë¸”ëŸ¬ëŠ” ë¶€í˜¸ ì—¬ë¶€ë¥¼ ì—„ê²©íˆ ê²€ì‚¬í•˜ì§€ ì•Šê³ , ë‹¨ìˆœíˆ ê°’ì„ 2ì˜ ë³´ìˆ˜ í˜•íƒœë¡œ ì €ì¥í•¨.

---

### **5. Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?**

**í•œê¸€:** EAX ë ˆì§€ìŠ¤í„°ì— 5ë¥¼ ë”í•˜ëŠ” ëª…ë ¹ê³¼ EDX ë ˆì§€ìŠ¤í„°ì— 5ë¥¼ ë”í•˜ëŠ” ëª…ë ¹ì„ ì‘ì„±í•˜ê³ , ë¦¬ìŠ¤íŒ… íŒŒì¼ì˜ ê¸°ê³„ì–´ ì½”ë“œë¥¼ ë¹„êµí•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

- `ADD EAX, 5` â†’ ì§§ì€ ì¸ì½”ë”©(íŠ¹ìˆ˜ ì˜¤í”¼ì½”ë“œ).
- `ADD EDX, 5` â†’ ì¼ë°˜ ì¸ì½”ë”©(ì˜¤í”¼ì½”ë“œ + ModR/M ë°”ì´íŠ¸).
    
    ğŸ‘‰ ê°™ì€ ë™ì‘ì´ë¼ë„ ë ˆì§€ìŠ¤í„°ì— ë”°ë¼ ê¸°ê³„ì–´ ì½”ë“œ ê¸¸ì´ê°€ ë‹¤ë¦„.
    

---

### **6. Given the number 456789ABh, list out its byte values in little-endian order.**

**í•œê¸€:** 456789ABh ê°’ì„ ë¦¬í‹€ ì—”ë””ì–¸ ìˆœì„œë¡œ ë‚˜ì—´í•˜ì‹œì˜¤.

âœ… ì •ë‹µ: `ABh, 89h, 67h, 45h`

---

### **7. Declare an array of 120 uninitialized unsigned doubleword values.**

**í•œê¸€:** ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ë¶€í˜¸ ì—†ëŠ” ë”ë¸”ì›Œë“œ 120ê°œ ë°°ì—´ì„ ì„ ì–¸í•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
arr DWORD 120 DUP(?)

```

---

### **8. Declare an array of byte and initialize it to the first 5 letters of the alphabet.**

**í•œê¸€:** ë°”ì´íŠ¸ ë°°ì—´ì„ ì„ ì–¸í•˜ê³  ì•ŒíŒŒë²³ ì²˜ìŒ 5ê¸€ìë¡œ ì´ˆê¸°í™”í•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
letters BYTE "ABCDE"

```

---

### **9. Declare a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value.**

**í•œê¸€:** 32ë¹„íŠ¸ ë¶€í˜¸ ìˆëŠ” ì •ìˆ˜ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  ê°€ì¥ ì‘ì€ ìŒìˆ˜ ê°’ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
minVal SDWORD -2147483648

```

---

### **10. Declare an unsigned 16-bit integer variable named wArray that uses three initializers.**

**í•œê¸€:** 16ë¹„íŠ¸ ë¶€í˜¸ ì—†ëŠ” ì •ìˆ˜í˜• ë³€ìˆ˜ `wArray`ë¥¼ ì„ ì–¸í•˜ê³  ì„¸ ê°œì˜ ì´ˆê¸°ê°’ì„ ì£¼ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
wArray WORD 1000, 2000, 3000

```

---

### **11. Declare a string variable containing the name of your favorite color. Initialize it as a null-terminated string.**

**í•œê¸€:** ê°€ì¥ ì¢‹ì•„í•˜ëŠ” ìƒ‰ê¹” ì´ë¦„ì„ ë‹´ì€ ë¬¸ìì—´ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  ë„ ì¢…ë£Œ ë¬¸ìì—´ë¡œ ì´ˆê¸°í™”í•˜ì‹œì˜¤.

âœ… ì •ë‹µ (ì˜ˆ: BLUE):

```nasm
colorName BYTE "Blue", 0

```

---

### **12. Declare an uninitialized array of 50 signed doublewords named dArray.**

**í•œê¸€:** ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ë¶€í˜¸ ìˆëŠ” ë”ë¸”ì›Œë“œ 50ê°œ ë°°ì—´ `dArray`ë¥¼ ì„ ì–¸í•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
dArray SDWORD 50 DUP(?)

```

---

### **13. Declare a string variable containing the word â€œTESTâ€ repeated 500 times.**

**í•œê¸€:** "TEST" ë‹¨ì–´ë¥¼ 500ë²ˆ ë°˜ë³µí•œ ë¬¸ìì—´ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
bigStr BYTE 500 DUP("TEST")

```

---

### **14. Declare an array of 20 unsigned bytes named bArray and initialize all elements to zero.**

**í•œê¸€:** 20ê°œì˜ ë¶€í˜¸ ì—†ëŠ” ë°”ì´íŠ¸ ë°°ì—´ `bArray`ë¥¼ ì„ ì–¸í•˜ê³ , ëª¨ë“  ìš”ì†Œë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œì˜¤.

âœ… ì •ë‹µ:

```nasm
bArray BYTE 20 DUP(0)

```

---

### **15. Show the order of individual bytes in memory (lowest to highest) for the following doubleword variable: val1 DWORD 87654321h**

**í•œê¸€:** ë‹¤ìŒ ë”ë¸”ì›Œë“œ ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ ë‚´ ë°”ì´íŠ¸ ìˆœì„œë¥¼ (ë‚®ì€ ì£¼ì†Œ â†’ ë†’ì€ ì£¼ì†Œ) ë‚˜ì—´í•˜ì‹œì˜¤:

```nasm
val1 DWORD 87654321h

```

âœ… ì •ë‹µ (ë¦¬í‹€ ì—”ë””ì–¸ ê¸°ì¤€): `21h, 43h, 65h, 87h`

## ğŸ“˜ 3.1.0 Programming Exercises

# **ë¬¸ì œ 1. Integer Expression Calculation**

> **AddTwo í”„ë¡œê·¸ë¨(3.2ì ˆ ì˜ˆì œ)**ë¥¼ ì°¸ê³ í•˜ì—¬, ë ˆì§€ìŠ¤í„°ë¥¼ ì‚¬ìš©í•´ ë‹¤ìŒ ìˆ˜ì‹ì„ ê³„ì‚°í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.
> 

A=(A+B)âˆ’(C+D)A = (A + B) - (C + D)

A=(A+B)âˆ’(C+D)

- **EAX â†’ A**
- **EBX â†’ B**
- **ECX â†’ C**
- **EDX â†’ D**

---

### âœ… í’€ì´ ë°©ë²•

1. `EAX`ì— A ê°’ì„ ì €ì¥í•œë‹¤.
2. `EBX` ê°’ì„ ë”í•´ `(A+B)`ë¥¼ ë§Œë“ ë‹¤.
3. `ECX`ì™€ `EDX`ë¥¼ ë”í•´ `(C+D)`ë¥¼ ë§Œë“ ë‹¤.
4. `EAX`ì—ì„œ `(C+D)` ê°’ì„ ë¹¼ ìµœì¢… ê²°ê³¼ `(A+B) - (C+D)`ë¥¼ ì–»ëŠ”ë‹¤.
5. ê²°ê³¼ëŠ” `EAX` ë ˆì§€ìŠ¤í„°ì— ì €ì¥ëœë‹¤.

---

### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (MASM)

```nasm
; CalcExpr.asm - calculates A = (A + B) - (C + D)
; Reference: AddTwo.asm (Chapter 3 example)

.386
.model flat,stdcall
.stack 4096
ExitProcess proto, dwExitCode:dword

.code
main proc
    ; ì˜ˆì‹œ ê°’ í• ë‹¹
    mov eax, 10      ; A = 10
    mov ebx, 5       ; B = 5
    mov ecx, 3       ; C = 3
    mov edx, 2       ; D = 2

    ; (A + B)
    add eax, ebx     ; EAX = A + B

    ; (C + D)
    add ecx, edx     ; ECX = C + D

    ; (A + B) - (C + D)
    sub eax, ecx     ; EAX = (A + B) - (C + D)

    ; ê²°ê³¼ëŠ” EAXì— ì €ì¥ë¨
    invoke ExitProcess, 0
main endp
end main

```

---

### ğŸ“Š ì‹¤í–‰ ì˜ˆì‹œ

- A=10, B=5, C=3, D=2ì¼ ë•Œ:
    
    ```
    (10 + 5) - (3 + 2) = 15 - 5 = 10
    
    ```
    
- ìµœì¢… ê²°ê³¼: **EAX = 10**

# **ë¬¸ì œ 2. Symbolic Integer Constants**

> ì¼ì£¼ì¼ì˜ 7ì¼ì„ ëª¨ë‘ ê¸°í˜¸ ìƒìˆ˜(symbolic constants)ë¡œ ì •ì˜í•˜ì‹œì˜¤.
> 
> 
> ê·¸ë¦¬ê³  ì´ ìƒìˆ˜ë“¤ì„ ì´ˆê¸°ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ë°°ì—´ ë³€ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.
> 

---

### âœ… í’€ì´ ë°©ë²•

1. `EQU` ì§€ì‹œë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ì›”~ì¼ì„ **ê¸°í˜¸ ìƒìˆ˜**ë¡œ ì •ì˜í•œë‹¤.
    - ì˜ˆ: `MONDAY EQU 1`
2. `.data` ì˜ì—­ì— ë°°ì—´ì„ ì„ ì–¸í•˜ê³ , ê° ìš”ì¼ ê¸°í˜¸ ìƒìˆ˜ë¥¼ ì´ˆê¸°ê°’ìœ¼ë¡œ ë„£ëŠ”ë‹¤.
    - ì˜ˆ: `weekDays DWORD MONDAY, TUESDAY, ...`

---

### ğŸ’» ì½”ë“œ ì˜ˆì‹œ (MASM)

```nasm
; WeekDays.asm - defines symbolic constants for days of the week
; and creates an array using them

.386
.model flat,stdcall
.stack 4096
ExitProcess proto, dwExitCode:dword

; ê¸°í˜¸ ìƒìˆ˜ ì •ì˜
MONDAY    EQU 1
TUESDAY   EQU 2
WEDNESDAY EQU 3
THURSDAY  EQU 4
FRIDAY    EQU 5
SATURDAY  EQU 6
SUNDAY    EQU 7

.data
; ìš”ì¼ ë°°ì—´ (DWORD = 32ë¹„íŠ¸ ì •ìˆ˜)
weekDays DWORD MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY

.code
main proc
    ; ë°°ì—´ ì„ ì–¸ ì˜ˆì œ í”„ë¡œê·¸ë¨ì´ë¯€ë¡œ ê³„ì‚°ì€ ìƒëµ
    invoke ExitProcess, 0
main endp
end main

```

---

### ğŸ“Š ë©”ëª¨ë¦¬ ì´ˆê¸°ê°’ ì˜ˆì‹œ

`weekDays` ë°°ì—´ì—ëŠ” ì•„ë˜ ê°’ë“¤ì´ ì €ì¥ë¨:

```
1, 2, 3, 4, 5, 6, 7

```

# **ë¬¸ì œ 3. Data Definitions**

> Table 3-2ì˜ ëª¨ë“  ë°ì´í„° íƒ€ì…ì„ ì •ì˜í•˜ê³ , ê° íƒ€ì…ì— ë§ëŠ” ê°’ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì‹œì˜¤.
> 

---

### ğŸ’» MASM ì½”ë“œ ì˜ˆì‹œ

```nasm
; DataTypes.asm - Definitions of all intrinsic data types (Table 3-2)

.386
.model flat,stdcall
.stack 4096
ExitProcess proto, dwExitCode:dword

.data
; 8-bit
uByteVar   BYTE   255        ; 8-bit unsigned (0 ~ 255)
sByteVar   SBYTE  -128       ; 8-bit signed (-128 ~ 127)

; 16-bit
uWordVar   WORD   65535      ; 16-bit unsigned (0 ~ 65535)
sWordVar   SWORD  -32768     ; 16-bit signed (-32768 ~ 32767)

; 32-bit
uDwordVar  DWORD  4294967295 ; 32-bit unsigned (0 ~ 4,294,967,295)
sDwordVar  SDWORD -2147483648 ; 32-bit signed (-2,147,483,648 ~ 2,147,483,647)

; 48-bit (Far pointer ìš©ë„)
fWordVar   FWORD  123456789ABC h ; 48-bit integer example (hexadecimal)

; 64-bit
qWordVar   QWORD  1234567890ABCDEFh ; 64-bit integer

; 80-bit (Ten-byte)
tByteVar   TBYTE  112233445566778899AABh ; 80-bit integer

; Floating-point
real4Var   REAL4  3.14       ; 32-bit short real
real8Var   REAL8  2.718281828 ; 64-bit long real
real10Var  REAL10 1.6180339887 ; 80-bit extended real

.code
main proc
    invoke ExitProcess, 0
main endp
end main

```

---

### ğŸ“Š ì •ë¦¬

| íƒ€ì… | ì˜ˆì œ ë³€ìˆ˜ëª… | ì´ˆê¸°ê°’ |
| --- | --- | --- |
| BYTE | uByteVar | 255 |
| SBYTE | sByteVar | -128 |
| WORD | uWordVar | 65535 |
| SWORD | sWordVar | -32768 |
| DWORD | uDwordVar | 4294967295 |
| SDWORD | sDwordVar | -2147483648 |
| FWORD | fWordVar | 123456789ABCh |
| QWORD | qWordVar | 1234567890ABCDEFh |
| TBYTE | tByteVar | 112233445566778899AABh |
| REAL4 | real4Var | 3.14 |
| REAL8 | real8Var | 2.718281828 |
| REAL10 | real10Var | 1.6180339887 |

---

4. Symbolic Text Constants
Write a program that defines symbolic names for several string literals (characters between
quotes). Use each symbolic name in a variable definition

# **ë¬¸ì œ4. ìƒì§•ì  ë¬¸ìì—´ ìƒìˆ˜**

ì—¬ëŸ¬ ë¬¸ìì—´ ë¦¬í„°ëŸ´(í°ë”°ì˜´í‘œë¡œ ë¬¶ì¸ ë¬¸ì)ì— ëŒ€í•´ ìƒì§•ì  ì´ë¦„(symbolic name)ì„ ì •ì˜í•˜ê³ , ê° ìƒì§•ì  ì´ë¦„ì„ ë³€ìˆ˜ ì •ì˜ì— ì‚¬ìš©í•˜ì‹œì˜¤.

---

### **ì˜ˆì œ ë‹µì•ˆ (NASM, x86 32-bit)**

```nasm
section .data
    GREETING db "ì•ˆë…•í•˜ì„¸ìš”", 0      ; ë¬¸ìì—´ ëì— NULL(0) ì¶”ê°€
    FAREWELL db "ì•ˆë…•íˆ ê°€ì„¸ìš”", 0
    QUESTION db "ì˜¤ëŠ˜ ê¸°ë¶„ì€ ì–´ë– ì„¸ìš”?", 0
    THANKS   db "ê°ì‚¬í•©ë‹ˆë‹¤", 0

section .text
    global _start

_start:
    ; ì˜ˆì‹œ: GREETING ë¬¸ìì—´ ì¶œë ¥
    mov edx, 15          ; ë¬¸ìì—´ ê¸¸ì´ (í•œê¸€ 5ê¸€ì * 3ë°”ì´íŠ¸ UTF-8) <- ì •í™•íˆ ê³„ì‚° í•„ìš”
    mov ecx, GREETING    ; ì¶œë ¥í•  ë¬¸ìì—´ ì£¼ì†Œ
    mov ebx, 1           ; stdout
    mov eax, 4           ; sys_write
    int 0x80

    ; í”„ë¡œê·¸ë¨ ì¢…ë£Œ
    mov eax, 1           ; sys_exit
    xor ebx, ebx
    int 0x80

```

---

### **ì„¤ëª…**

1. `db "ë¬¸ìì—´", 0`
    - ë¬¸ìì—´ì„ ì •ì˜í•˜ê³ , ëì— `0`ì„ ë¶™ì—¬ì„œ NULL ì¢…ë£Œ.
    - ì´ ë°©ì‹ìœ¼ë¡œ ìƒì§•ì  ì´ë¦„(GREETING, FAREWELL ë“±)ì„ ë§Œë“¤ì–´ì„œ ë³€ìˆ˜ì²˜ëŸ¼ ì‚¬ìš© ê°€ëŠ¥.
2. `mov ecx, GREETING`
    - `GREETING`ì€ ë¬¸ìì—´ ì‹œì‘ ì£¼ì†Œë¥¼ ì˜ë¯¸í•˜ë¯€ë¡œ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.
3. `mov eax, 4 / int 0x80`
    - ë¦¬ëˆ…ìŠ¤ì—ì„œ `sys_write` ì‹œìŠ¤í…œ ì½œì„ ì´ìš©í•´ ë¬¸ìì—´ì„ ì¶œë ¥.




5. Listing File for AddTwoSum
Generate a listing file for the AddTwoSum program and write a description of the machine code
bytes generated for each instruction. You might have to guess at some of the meanings of the
byte values
# **ë¬¸ì œ5. AddTwoSum í”„ë¡œê·¸ë¨ì˜ ë¦¬ìŠ¤íŒ… íŒŒì¼ ìƒì„±**
AddTwoSum í”„ë¡œê·¸ë¨ì˜ ë¦¬ìŠ¤íŒ… íŒŒì¼ì„ ìƒì„±í•˜ê³ , ê° ëª…ë ¹ì–´ì— ëŒ€í•´ ìƒì„±ëœ ê¸°ê³„ì–´ ë°”ì´íŠ¸ì— ëŒ€í•œ ì„¤ëª…ì„ ì‘ì„±í•˜ì‹­ì‹œì˜¤. ì¼ë¶€ ë°”ì´íŠ¸ ê°’ì˜ ì˜ë¯¸ë¥¼ ì¶”ì¸¡í•´ì•¼ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

## **1.AddTwoSum.asm í”„ë¡œê·¸ë¨ (ì°¸ê³ )**

```nasm
; AddTwoSum.asm - Chapter 3 example.

.386
.model flat,stdcall
.stack 4096
ExitProcess proto,dwExitCode:dword

.data
sum dword 0

.code
main proc
    mov eax,5
    add eax,6
    mov sum,eax

    invoke ExitProcess,0
main endp
end main

```

---

## **2. Listing File ì˜ˆì‹œ (ê° ëª…ë ¹ì–´ì™€ ë¨¸ì‹  ì½”ë“œ ë°”ì´íŠ¸)**

| ì–´ì…ˆë¸”ë¦¬ ëª…ë ¹ì–´ | ë¨¸ì‹  ì½”ë“œ ë°”ì´íŠ¸ (ì˜ˆì‹œ) | ì„¤ëª… |
| --- | --- | --- |
| `mov eax,5` | `B8 05 00 00 00` | `B8` â†’ `MOV EAX, imm32`, `05 00 00 00` â†’ 32ë¹„íŠ¸ ì¦‰ì‹œê°’ 5 |
| `add eax,6` | `83 C0 06` | `83` â†’ ALU ëª…ë ¹ + 8bit ì¦‰ì‹œê°’, `C0` â†’ EAX ë ˆì§€ìŠ¤í„° ì§€ì •, `06` â†’ ì¦‰ì‹œê°’ 6 |
| `mov sum,eax` | `A3 ?? ?? ?? ??` | `A3` â†’ MOV moffs32,EAX, `?? ?? ?? ??` â†’ sumì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œ (ë§ì»¤ì—ì„œ ê²°ì •) |
| `invoke ExitProcess,0` | `B8 00 00 00 00FF 15 ?? ?? ?? ??` | `B8 00 00 00 00` â†’ ì¸ì 0ì„ EAXë¡œ ë¡œë“œ, `FF 15 ?? ?? ?? ??` â†’ CALL DWORD PTR [ExitProcess] (ì£¼ì†ŒëŠ” ë§ì»¤ê°€ ê²°ì •) |

> ì°¸ê³ : ?? ?? ?? ??ëŠ” ë§ì»¤ê°€ ìµœì¢… ì£¼ì†Œë¥¼ í• ë‹¹í•˜ê¸° ì „ì—ëŠ” ì•Œ ìˆ˜ ì—†ëŠ” ê°’ì…ë‹ˆë‹¤.
> 

---

## **3. ë°”ì´íŠ¸ë³„ ì„¤ëª…**

1. **`mov eax,5` â†’ `B8 05 00 00 00`**
    - `B8` : opcode, EAXì— ì¦‰ì‹œê°’ ì´ë™
    - `05 00 00 00` : little-endian ë°©ì‹ìœ¼ë¡œ 32ë¹„íŠ¸ ìˆ«ì 5
2. **`add eax,6` â†’ `83 C0 06`**
    - `83` : 8-bit ì¦‰ì‹œê°’ì„ ì‚¬ìš©í•œ ADD ëª…ë ¹
    - `C0` : ModR/M byte, ëŒ€ìƒ = EAX
    - `06` : ë”í•  ê°’ 6
3. **`mov sum,eax` â†’ `A3 ?? ?? ?? ??`**
    - `A3` : ë©”ëª¨ë¦¬ ì§ì ‘ ì£¼ì†Œ(moffs32)ë¡œ EAX ì´ë™
    - `?? ?? ?? ??` : sum ë³€ìˆ˜ì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œ (ë§ì»¤ì—ì„œ ê²°ì •)
4. **`invoke ExitProcess,0` â†’ `B8 00 00 00 00 / FF 15 ?? ?? ?? ??`**
    - `B8 00 00 00 00` : EAX ë ˆì§€ìŠ¤í„°ì— 0 ë¡œë“œ (Exit code)
    - `FF 15 ?? ?? ?? ??` : ë©”ëª¨ë¦¬ ì£¼ì†Œì— ìˆëŠ” ExitProcess í•¨ìˆ˜ í˜¸ì¶œ

# **ë¬¸ì œ 6**
6. AddVariables Program
 Modify the AddVariables program so it uses 64-bit variables. Describe the syntax errors gener
ated by the assembler and what steps you took to resolve the errors
6. AddVariables í”„ë¡œê·¸ë¨
AddVariables í”„ë¡œê·¸ë¨ì„ ìˆ˜ì •í•˜ì—¬ 64ë¹„íŠ¸ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•˜ì‹­ì‹œì˜¤. ì–´ì…ˆë¸”ëŸ¬ì—ì„œ ìƒì„±ëœ êµ¬ë¬¸ ì˜¤ë¥˜ì™€ í•´ë‹¹ ì˜¤ë¥˜ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ì·¨í•œ ì¡°ì¹˜ë¥¼ ì„¤ëª…í•˜ì‹­ì‹œì˜¤.

## **1. ì›ë˜ í”„ë¡œê·¸ë¨ (ì°¸ê³ )**

```nasm
; AddVariables.asm - Chapter 3 example.

.386
.model flat,stdcall
.stack 4096
ExitProcess proto,dwExitCode:dword

.data
firstval  dword 20002000h
secondval dword 11111111h
thirdval  dword 22222222h
sum dword 0

.code
main proc
    mov eax,firstval
    add eax,secondval
    add eax,thirdval
    mov sum,eax

    invoke ExitProcess,0
main endp
end main

```

---

## **2. 64-bit ë³€ìˆ˜ë¡œ ìˆ˜ì •**

1. 32-bit `dword` â†’ 64-bit `qword`
2. 32-bit ë ˆì§€ìŠ¤í„°(`eax`) â†’ 64-bit ë ˆì§€ìŠ¤í„°(`rax`)

```nasm
; AddVariables64.asm - 64-bit variables version

.model flat,stdcall
.stack 4096
ExitProcess proto,dwExitCode:QWORD

.data
firstval  qword 20002000h
secondval qword 11111111h
thirdval  qword 22222222h
sum       qword 0

.code
main proc
    mov rax,firstval      ; 64-bit ë ˆì§€ìŠ¤í„° ì‚¬ìš©
    add rax,secondval
    add rax,thirdval
    mov sum,rax

    invoke ExitProcess,0
main endp
end main

```

---

## **3. ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ë²• ì˜¤ë¥˜(Syntax Error)ì™€ í•´ê²° ë°©ë²•**

| ì˜¤ë¥˜ ë©”ì‹œì§€ (ì˜ˆì‹œ) | ì›ì¸ | í•´ê²° ë°©ë²• |
| --- | --- | --- |
| `error A2070: invalid combination of opcode and operand` | `mov eax, firstval`ì—ì„œ 32-bit ë ˆì§€ìŠ¤í„°ì™€ 64-bit ë³€ìˆ˜ ì‚¬ìš© | 32-bit ë ˆì§€ìŠ¤í„°(`eax`) â†’ 64-bit ë ˆì§€ìŠ¤í„°(`rax`)ë¡œ ë³€ê²½ |
| `error A2003: unknown data type` | `ExitProcess proto,dwExitCode:dword` ê·¸ëŒ€ë¡œ ì‚¬ìš© | `dword` â†’ 64-bit í™˜ê²½ì— ë§ê²Œ `QWORD`ë¡œ ë³€ê²½ |
| `operand size mismatch` | `add eax, secondval`ì—ì„œ ë ˆì§€ìŠ¤í„° í¬ê¸°ì™€ ë³€ìˆ˜ í¬ê¸° ë¶ˆì¼ì¹˜ | `eax` â†’ `rax`ë¡œ ë³€ê²½ |
| ê¸°íƒ€ ì£¼ì†Œ ê´€ë ¨ ì˜¤ë¥˜ | 32-bit ì½”ë“œ(`.386`) + 64-bit ë³€ìˆ˜ ì‚¬ìš© | `.386` ì œê±°, 64-bit í™˜ê²½ì—ì„œ ì–´ì…ˆë¸”ë¦¬ ìˆ˜í–‰ |

---

### **4. ìˆ˜ì • í›„ ìš”ì•½**

1. ë°ì´í„° ì„¹ì…˜: `dword` â†’ `qword`
2. ë ˆì§€ìŠ¤í„°: `eax` â†’ `rax`
3. í•¨ìˆ˜ í”„ë¡œí† íƒ€ì…: `dword` â†’ `qword`
4. `.386` ì§€ì‹œë¬¸ ì œê±° ë˜ëŠ” `.x64` ì‚¬ìš© (MASM 64-bit í™˜ê²½ì—ì„œëŠ” `.386` ë¶ˆí•„ìš”)
5. ë ˆì§€ìŠ¤í„° í¬ê¸°ì™€ ë³€ìˆ˜ í¬ê¸°ê°€ í•­ìƒ ì¼ì¹˜í•˜ë„ë¡ ì£¼ì˜
