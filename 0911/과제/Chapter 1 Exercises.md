### **1. Most Significant Bit (MSB)**
* **번역:** 8비트 2진수에서 가장 중요한 비트(MSB)는 무엇인가요?
* **답:** 가장 왼쪽에 있는 **비트 7(bit 7)**입니다.
    * **설명:** 8비트(1바이트) 데이터에서 맨 왼쪽 비트는 $2^7$, 즉 128을 나타내는 가장 큰 자릿값을 갖습니다. 또한, 컴퓨터가 음수를 표현하는 표준 방식인 '2의 보수' 표현법에서는 이 비트가 **부호 비트**의 역할을 합니다. MSB가 `0`이면 양수 또는 0, `1`이면 음수를 의미합니다.

***

### **2. Unsigned Binary to Decimal Conversion**
* **번역:** 다음 각 부호 없는 2진수를 10진수로 변환하면 무엇인가요?
* **답:**
    * a. `00110101` → **53**
    * b. `10010110` → **150**
    * c. `11001100` → **204**
    * **설명:** 2진법은 2를 밑으로 하는 수 체계입니다. 각 자리는 오른쪽부터 $2^0, 2^1, 2^2, 2^3, \dots$ 순서로 2의 거듭제곱 값을 갖습니다. `1`로 표시된 비트의 자릿값들을 모두 더하면 10진수로 변환할 수 있습니다. 예를 들어, `00110101`은 $(1 \times 2^5) + (1 \times 2^4) + (1 \times 2^2) + (1 \times 2^0) = 32+16+4+1 = 53$ 입니다.

***

### **3. Binary Addition**
* **번역:** 다음 각 2진수 쌍을 더하면 무엇인가요?
* **답:**
    * a. `10101111 + 11011011` → **110001010**
    * b. `10010111 + 11111111` → **110010110**
    * c. `01110101 + 10101100` → **100100001**
    * **설명:** 10진법 덧셈과 원리는 동일합니다. 각 자리의 비트를 더하다가 합이 2가 되면 (`1+1`), 해당 자리에는 `0`을 쓰고 다음 자리로 `1`을 올림수(carry)로 전달합니다. 이 과정은 CPU 내부의 **ALU(산술 논리 장치)**에서 수행하는 기본적인 연산입니다.

***

### **4. Binary Subtraction**
* **번역:** 2진수 `00001101`에서 `00000111`을 빼면 무엇인가요?
* **답:** **`00000110`**
    * **설명:** 뺄셈 역시 윗자리에서 빌려오는(borrow) 과정이 있습니다. 2진법에서는 윗자리에서 `1`을 빌려오면 현재 자리에서는 `2`로 계산됩니다. 참고로, 실제 컴퓨터는 뺄셈을 '2의 보수'를 이용한 덧셈 연산으로 변환하여 처리합니다.

***

### **5. Data Type Sizes**
* **번역:** 다음 각 데이터 타입은 몇 비트를 사용하나요?
* **답:**
    * a. `word` → **16 bits**
    * b. `doubleword` → **32 bits**
    * c. `quadword` → **64 bits**
    * d. `double quadword` → **128 bits**
    * **설명:** CPU가 한 번에 효율적으로 처리할 수 있는 데이터의 표준 크기 단위입니다. '32비트 CPU'나 '64비트 CPU'라고 부르는 것은 각각 **더블워드**와 **쿼드워드** 크기의 데이터를 중심으로 설계되었음을 의미합니다.

***

### **6. Minimum Bits for Unsigned Integers**
* **번역:** 다음 각 10진수를 표현하기 위해 필요한 최소 비트 수는 몇 개인가요?
* **답:**
    * a. `4095` → **12 bits**
    * b. `65534` → **16 bits**
    * c. `42319` → **16 bits**
    * **설명:** N개의 비트로 표현할 수 있는 부호 없는 정수의 최댓값은 $2^N - 1$ 입니다. 따라서 주어진 숫자를 표현하려면, $2^N - 1$이 그 숫자보다 크거나 같아지는 최소의 N값을 찾으면 됩니다.

***

### **7. Binary to Hexadecimal Conversion**
* **번역:** 다음 각 2진수를 16진수로 변환하면 무엇인가요?
* **답:**
    * a. `0011 0101 1101 1010` → **`35DA`**
    * b. `1100 1110 1010 0011` → **`CEA3`**
    * c. `1111 1110 1101 1011` → **`FEDB`**
    * **설명:** 2진수는 길어지면 가독성이 떨어지므로, 보통 16진법(Hexadecimal)을 축약형으로 사용합니다. $16 = 2^4$ 이기 때문에, 2진수 네 자리를 한 묶음으로 하여 하나의 16진수 숫자로 완벽하게 변환할 수 있습니다. 메모리 주소나 파일 내용을 표현할 때 흔히 사용됩니다.

***

### **8. Hexadecimal to Binary Conversion**
* **번역:** 다음 각 16진수를 2진수로 변환하면 무엇인가요?
* **답:**
    * a. `0126F9D4` → **`0000 0001 0010 0110 1111 1001 1101 0100`**
    * b. `6ACDFA95` → **`0110 1010 1100 1101 1111 1010 1001 0101`**
    * c. `F69BDC2A` → **`1111 0110 1001 1011 1101 1100 0010 1010`**
    * **설명:** 7번의 역변환 과정입니다. 16진수 숫자 하나를 각각 4비트의 2진수 그룹으로 풀어쓰면 됩니다. 예를 들어, 16진수 `F`는 10진수 15이므로, 2진수 `1111`로 변환됩니다.

***

### **9. Unsigned Hexadecimal to Decimal Conversion**
* **번역:** 다음 각 부호 없는 16진수를 10진수로 변환하면 무엇인가요?
* **답:**
    * a. `3A` → **58**
    * b. `1BF` → **447**
    * c. `1001` → **4097**
    * **설명:** 16진법은 16을 밑으로 하는 수 체계로, 각 자리는 오른쪽부터 $16^0, 16^1, 16^2, \dots$ 의 가중치를 갖습니다. 각 자리의 숫자(0~9, A~F는 10~15)에 해당 자릿값을 곱한 후 모두 더하면 10진수 값이 됩니다. 예를 들어 `3A`는 $(3 \times 16^1) + (10 \times 16^0) = 48 + 10 = 58$ 입니다.
 
***

### **10. Unsigned Hexadecimal to Decimal**
* **번역:** 다음 각 부호 없는 16진수를 10진수로 변환하면 무엇인가요?
* **답:**
    * a. `62` → **98**
    * b. `4B3` → **1203**
    * c. `29F` → **671**
    * **설명:** 16진법은 16을 밑으로 하는 수 체계입니다. 각 자리의 숫자(0~9, A~F는 10~15)에 해당 자릿값($16^0, 16^1, 16^2, \dots$)을 곱한 후 모두 더하면 10진수 값이 됩니다. 예를 들어 `62`는 $(6 \times 16^1) + (2 \times 16^0) = 96 + 2 = 98$ 입니다.

***

### **11. Signed Decimal to 16-bit Hexadecimal**
* **번역:** 다음 각 부호 있는 10진수를 16비트 16진수로 표현하면 무엇인가요?
* **답:**
    * a. `-24` → **`FFE8`**
    * b. `-331` → **`FEB5`**
    * **설명:** 컴퓨터에서 음수를 표현하는 표준 방식인 **'2의 보수'**를 사용합니다. 먼저 숫자의 절댓값(예: 24)을 16비트 2진수로 변환한 뒤, 모든 비트(0은 1로, 1은 0으로)를 뒤집고, 마지막으로 그 결과에 1을 더하여 16진수로 변환하면 됩니다.

***

### **12. Signed Decimal to 16-bit Hexadecimal**
* **번역:** 다음 각 부호 있는 10진수를 16비트 16진수로 표현하면 무엇인가요?
* **답:**
    * a. `-21` → **`FFEB`**
    * b. `-45` → **`FFD3`**
    * **설명:** 11번 문제와 동일하게 '2의 보수' 변환법을 적용하여 10진수 음수를 16비트 16진수로 변환합니다.

***

### **13. Signed 16-bit Hexadecimal to Decimal**
* **번역:** 다음 부호 있는 16비트 16진수를 10진수로 변환하면 무엇인가요?
* **답:**
    * a. `6BF9` → **27641**
    * b. `C123` → **-16093**
    * **설명:** 16비트 데이터의 최상위 비트(MSB)가 부호를 결정합니다. `6BF9`의 첫 숫자인 6은 2진수로 `0110`이므로 MSB가 0, 즉 양수입니다. `C123`의 첫 숫자인 C는 `1100`이므로 MSB가 1, 즉 음수이며 '2의 보수' 규칙에 따라 원래의 음수 값을 찾아야 합니다.

***

### **14. Signed 16-bit Hexadecimal to Decimal**
* **번역:** 다음 부호 있는 16비트 16진수를 10진수로 변환하면 무엇인가요?
* **답:**
    * a. `4CD2` → **19666**
    * b. `8230` → **-32208**
    * **설명:** 13번 문제와 동일한 원리입니다. 맨 앞의 16진수 숫자가 0~7이면 양수, 8~F이면 음수입니다. 음수인 경우 '2의 보수' 역변환(1을 빼고 비트 반전)을 통해 절댓값을 구합니다.

***

### **15. Signed Binary to Decimal**
* **번역:** 다음 각 부호 있는 2진수를 10진수로 변환하면 무엇인가요?
* **답:**
    * a. `10110101` → **-75**
    * b. `00101010` → **42**
    * c. `11110000` → **-16**
    * **설명:** 8비트 2진수에서 가장 왼쪽 비트(MSB)가 `0`이면 양수, `1`이면 음수입니다. 양수는 그대로 10진수로 변환하고, 음수는 '2의 보수' 규칙을 역으로 적용하여 원래의 10진수 값을 찾습니다.

***

### **16. Signed Binary to Decimal**
* **번역:** 다음 각 부호 있는 2진수를 10진수로 변환하면 무엇인가요?
* **답:**
    * a. `10000000` → **-128**
    * b. `11001100` → **-52**
    * c. `10110111` → **-73**
    * **설명:** 15번 문제와 동일한 원리입니다. 특히 `10000000`은 8비트로 표현할 수 있는 가장 작은 음수인 -128을 나타내는 특별한 경우입니다.

***

### **17. Signed Decimal to 8-bit Binary**
* **번역:** 다음 각 부호 있는 10진수를 8비트 2진수(2의 보수)로 표현하면 무엇인가요?
* **답:**
    * a. `-5` → **`11111011`**
    * b. `-42` → **`11010110`**
    * c. `-16` → **`11110000`**
    * **설명:** 10진수 음수를 8비트 2진수로 바꾸는 '2의 보수' 변환 과정입니다.
        1.  숫자의 절댓값을 8비트 2진수로 만듭니다. (예: 5 → `00000101`)
        2.  모든 비트를 반전시킵니다. (`00000101` → `11111010`, 1의 보수)
        3.  결과에 1을 더합니다. (`11111010` + 1 → `11111011`, 2의 보수)

***

### **18. Signed Decimal to 8-bit Binary**
* **번역:** 다음 각 부호 있는 10진수를 8비트 2진수(2의 보수)로 표현하면 무엇인가요?
* **답:**
    * a. `-72` → **`10111000`**
    * b. `-98` → **`10011110`**
    * c. `-26` → **`11100110`**
    * **설명:** 17번 문제와 동일하게 '2의 보수' 변환 규칙을 사용하여 10진수 음수를 8비트 2진수로 표현합니다.

***

### **19. Hexadecimal Sum**
* **번역:** 다음 각 16진수 쌍의 합은 무엇인가요?
* **답:**
    * a. `6B4 + 3FE` → **AB2**
    * b. `A49 + 6BD` → **1106**
    * **설명:** 10진수 덧셈처럼 각 자리를 더하되, 합이 16을 넘어가면 16으로 나눈 나머지를 현재 자리에 쓰고 몫을 올림수(carry)로 다음 자리로 넘겨 계산합니다. 이 과정은 CPU의 산술논리장치(ALU)가 수행하는 기본적인 연산입니다.

***

### **20. Hexadecimal Sum**
* **번역:** 다음 각 16진수 쌍의 합은 무엇인가요?
* **답:**
    * a. `7C4 + 3BE` → **B82**
    * b. `B69 + 7AD` → **1316**
    * **설명:** 19번 문제와 동일한 16진법 덧셈 원리를 적용합니다. 각 자릿수의 합이 16이 되면 다음 자리로 1을 올려줍니다.

***

### **21. ASCII Character 'B'**
* **번역:** ASCII 문자 대문자 'B'의 16진수와 10진수 표현은 무엇인가요?
* **답:**
    * 16진수: **42**
    * 10진수: **66**
    * **설명:** 아스키(ASCII)는 문자를 컴퓨터가 이해할 수 있는 숫자에 대응시킨 표준 코드 체계입니다. 대문자 'A'가 10진수 65번에 할당되어 있고, 'B'는 그 다음 문자로 66번에 해당합니다.

***

### **22. ASCII Character 'G'**
* **번역:** ASCII 문자 대문자 'G'의 16진수와 10진수 표현은 무엇인가요?
* **답:**
    * 16진수: **47**
    * 10진수: **71**
    * **설명:** 대문자 'A'(65)를 기준으로 'G'는 6번째 뒤의 문자이므로, 65+6=71에 해당합니다.

***

### **23. Challenge: Largest 129-bit Unsigned Value**
* **번역:** 129비트 부호 없는 정수를 사용하여 표현할 수 있는 가장 큰 10진수 값은 무엇인가요?
* **답:** **$2^{129} - 1$**
    * **설명:** N개의 비트로 표현할 수 있는 부호 없는 정수의 개수는 $2^N$개 (0부터 $2^N-1$까지)이므로, 최댓값은 $2^N - 1$이 됩니다.

***

### **24. Challenge: Largest 86-bit Signed Value**
* **번역:** 86비트 부호 있는 정수를 사용하여 표현할 수 있는 가장 큰 10진수 값은 무엇인가요?
* **답:** **$2^{85} - 1$**
    * **설명:** 부호 있는 정수는 첫 비트를 부호로 사용하므로, 값을 나타내는 비트는 N-1개가 됩니다. 따라서 최댓값은 $2^{N-1} - 1$이 됩니다.

***

### **25. Truth Table: ¬(A ∨ B)**
* **번역:** `¬(A ∨ B)`로 설명되는 불리언 함수에 대한 모든 가능한 입력 및 출력을 보여주는 진리표를 만드세요.
* **답:**
| A | B | A ∨ B | ¬(A ∨ B) |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | **1** |
| 0 | 1 | 1 | **0** |
| 1 | 0 | 1 | **0** |
| 1 | 1 | 1 | **0** |
    * **설명:** 이 표는 **NOR 논리 연산**의 진리표입니다. 'A 또는 B'의 결과(`A ∨ B`)를 반전(`¬`)시킨 것으로, A와 B가 모두 거짓(0)일 때만 참(1)이 됩니다.

***

### **26. Truth Table: (¬A ∧ ¬B) & De Morgan's Theorem**
* **번역:** `(¬A ∧ ¬B)`에 대한 진리표를 만드세요. 이 표의 맨 오른쪽 열은 25번 문제의 표와 어떤 관계가 있나요? 드모르간의 정리에 대해 들어본 적이 있나요?
* **답:**
| A | B | ¬A | ¬B | ¬A ∧ ¬B |
|:---:|:---:|:---:|:---:|:---:|
| 0 | 0 | 1 | 1 | **1** |
| 0 | 1 | 1 | 0 | **0** |
| 1 | 0 | 0 | 1 | **0** |
| 1 | 1 | 0 | 0 | **0** |
    * **설명:** 이 표의 결과는 25번 문제의 결과와 **완전히 동일**합니다. 이는 논리 대수학의 중요한 법칙인 **드모르간의 정리** `¬(A ∨ B) ≡ (¬A ∧ ¬B)`를 증명하는 것입니다.

***

### **27. Truth Table Rows for 4 Inputs**
* **번역:** 불리언 함수에 4개의 입력이 있다면, 진리표에 몇 개의 행이 필요한가요?
* **답:** **16개**
    * **설명:** 각 입력은 참/거짓(1/0)의 두 가지 경우를 가집니다. 따라서 N개의 입력에 대한 모든 가능한 조합의 수는 $2^N$가지입니다. 4개 입력의 경우 $2^4 = 16$개의 행이 필요합니다.

***

### **28. Multiplexer Selector Bits**
* **번역:** 4-입력 멀티플렉서에는 몇 개의 선택 비트가 필요한가요?
* **답:** **2개**
    * **설명:** 멀티플렉서(MUX)는 여러 입력선 중 하나를 선택하여 하나의 출력선으로 내보내는 장치입니다. S개의 선택 비트가 있으면 $2^S$개의 입력선을 제어할 수 있습니다. 4개의 입력선을 제어하려면 $2^S = 4$를 만족하는 S=2, 즉 2개의 선택 비트가 필요합니다.
